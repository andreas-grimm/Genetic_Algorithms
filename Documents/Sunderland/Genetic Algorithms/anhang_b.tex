\begin{verbatim}
pragma LIST(ON);

with text_io; use text_io;
with random; use random;
with fio; use fio;
with iio; use iio;

generic
\end{verbatim}
The definition of the variables which must be set before the instantiation looks
very simulary to the definition of the SGA package. The only additional variable
included is called {\tt MaxCrossPoints}. It is the controlling variable for the
fixed point crossover procedure. The programmer has to define the number of points
in the string where a crossover is allowed.
\begin{verbatim}
   MaxAllele            : integer;
   MaxPopSize           : integer;
   MaxCrossPoints       : integer;

package Advanced_Genetic_Algorithms is
\end{verbatim}
First comes a number of definitions of the most important types for the advanced
genetic algorithms. These types are :
  \begin{enumerate}
  \item {\tt Sex}: prepared for the implementation of sexuality in the crossover
  procedure, but in the moment it is not used.
  \item {\tt Crossing}: a new type with the possible values {\tt haploid} and
  {\tt diploid}. The meaning of these values is explained later.
  \item {\tt Haploid\_Method}: is a type with possible values : {\tt haploid},
  if the system has to perform a haploid crossover and {\tt diploid} otherwize.
  \item The types {\tt Individuum}, {\tt Population\_Array} and {\tt Fitness\_Array}
  are identical to the SGA package.
  \item {\tt Sex\_Array} containts information of the sex of each individual.
  \item {\tt Crossing\_Points} containts the possible points of crossover, if
  the method of crossover is haploid. In the other case it containts the list
  of dominant genes.
  \end{enumerate}
\begin{verbatim}
  type Sex              is (male,female);
  type Crossing         is (haploid, diploid);
  type Haploid_Method   is (fixed, randomize);
  type Individuum       is array (1..MaxAllele) of integer range 0..1;
  type Population_Array is array (1..MaxPopSize) of Individuum;
  type Fitness_Array    is array (1..MaxPopSize) of float;
  type Sex_Array        is array (1..MaxPopSize) of Sex;
  type Crossing_Points  is array (1..MaxCrossPoints) of integer;
\end{verbatim}
The definition of the procedure to initialize the population is identical
to the definition in the SGA package.
\begin{verbatim}
  procedure Init_Population (Population : in out Population_Array);
\end{verbatim}
The following lines are the definitions of the functions of the advanced
genetic algorithms. Most of the parameters are identical to the parameters
of the SGAs.
\begin{verbatim}
  procedure Roulette_Wheel (Population     : in out Population_Array;
                            Fitness        : in     Fitness_Array;
                            Generation_Gap : in     integer);
\end{verbatim}
The additional parameter at the roulette wheel procedure is the value for the
size of the generation gap. If the parameter is equal to 0 the procedure is
identical to the roulette wheel procedure of the SGA package.

The crossover procedure looks really different from the one in the SGA package.
It contains many more parameters which have to be explained. The parameters of
this procedure are :
\begin{enumerate}
  \item {\tt Population}: the population of the system,
  \item {\tt Method}: the method of the crossover. Values of this variable are
  {\tt haploid} and {\tt diploid}.
  \item {\tt Selection}: gives the possibilities for the haploid crossover
  methods. Possible values for this parameter are {\tt fixed} and {\tt randomized}.
  If this parameter has the value {\tt randomized} the point of crossover is
  selected randomly. Otherwise the array {\tt crossing} containts informations
  about the possible point where a crossover is allowed.
  \item {\tt Crossing}: depending on the value of {\tt Method} this variable
  has two different meanings. The use at a hapoid crossover is explained above.
  By using the diploid crossover this array contains informations about the dominant
  gene.
  \item {\tt No\_of\_Crossing\_Points}: this variable should contain the same
  information as the variable {\tt MaxCrossPoints}. But different to the variable
  {\tt MaxCrossPoints} this variable does not only reserve the space for the
  table the pointes of crossover are stored in but gives the real number of
  points for the crossover.
  \item {\tt Generation\_Gap}: the generation gap, see above.
\end{enumerate}
\begin{verbatim}
  procedure Crossover      (Population            : in out Population_Array;
                            Method                : in     Crossing;
                            Selection             : in     Haploid_Method;
                            Crossing              : in     Crossing_Points;
                            No_of_Crossing_Points : in     integer;
                            Generation_Gap        : in     integer);
\end{verbatim}
The procedure for mutation has the same expansions as the procedure for the
roulette wheel has. Therefor it need no more explaination.
\begin{verbatim}
  procedure Mutation       (Population     : in out Population_Array;
                            Mutationquote  : in     float;
                            Generation_Gap : in     integer);
\end{verbatim}
The following procedure is identical to the function in the SGA package.
\begin{verbatim}
  procedure Simple_Display (Generation     :        integer;
                            Population     : in     Population_Array;
                            Fitness        : in     Fitness_Array;
                            Org_Value      : in     Fitness_Array;
                            Calc_Value     : in     Fitness_Array);

end Advanced_Genetic_Algorithms;
\end{verbatim}
\section{The Package Body}
The next lines contains the package body. As written in the chapter before
it is normally closed as a secret and should not be used but for expansion
and improvement.
\begin{verbatim}
package body Advanced_Genetic_Algorithms is

  Best_Org_Value        : float := 0.0;
  Best_Calc_Value       : float := 0.0;
  Best_Generation       : integer := 0;
  Last_Gen_Accum_Org    : float := 0.0;
  Last_Gen_Accum_Calc   : float := 0.0;
\end{verbatim}
\subsubsection{The Initialisation Procedure}
The following procedure is the procedure to initialize the individuals. The procedure
is identical to the procedure in the SGA package.
\begin{verbatim}
  procedure Init_Population (Population : in out Population_Array) is
    t, x                : integer;
    Single_Individuum   : Individuum;
  begin
    for t in Population'Range loop
      for x in Population(t)'Range loop
        Single_Individuum(x) := random_ND_integer(65535) mod 2;
        if (Single_Individuum(x) > 1) then
          Single_Individuum(x) := 1;
        end if;
      end loop;
      Population(t) := Single_Individuum;
    end loop;
  end Init_Population;
\end{verbatim}
\subsubsection{The Selection Procedure}
\begin{verbatim}
Additional to the first roulette wheel implementation this system containts also
the mechanism of the generation gap. The individuals of with the best fitness
are transfered into the generation gap. After the roulette wheel has finished,
the individuals are transfered back into the population. Because the possition
of these inidividuals in the population is specified it is very simple for the
other procedures to continue with the gap.
\begin{verbatim}
  procedure Roulette_Wheel (Population     : in out Population_Array;
                            Fitness        : in     Fitness_Array;
                            Generation_Gap : in     integer) is
    New_Population : Population_Array;
    Gap            : Population_Array;
    Gap_Array      : array (1..MaxPopSize) of integer;
    Wheel_Length   : constant := 100;
    Wheel          : array (1..Wheel_Length) of integer;
    Position       : integer := 1;
    t              : integer;
    x              : integer;
    field          : integer;
    NettoPopSize   : integer;
    Dummy          : integer;

  begin
    NettoPopSize := MaxPopSize - Generation_Gap;
\end{verbatim}
The first step of the procedure is to calculate the size of the population
without the individuals in the gap.
\begin{verbatim}
    for t in Population'Range loop
      if (Fitness(t) >= 1.0) then
        for x in Position..(Position+integer(Fitness(t))) loop
          if (x <= 100) then
            Wheel(x):=t;
          end if;
        end loop;
        Position := Position + integer(Fitness(t));
      end if;
    end loop;
\end{verbatim}
The next one transferes the best individuals into the gap. Therefor the system
has to sort the fitness.
\begin{verbatim}
    for t in Population'Range loop
      Gap_Array(t) := t;
    end loop;
    for t in Population'Range loop
      for x in t..MaxPopSize loop
        if (Fitness(Gap_Array(t)) > Fitness(Gap_Array(x))) then
          Dummy        := Gap_Array(t);
          Gap_Array(t) := Gap_Array(x);
          Gap_Array(x) := Dummy;
        end if;
      end loop;
    end loop;
    for t in 1..Generation_Gap loop
      Population(NettoPopSize + t) := Population(Gap_Array(t));
    end loop;
\end{verbatim}
Start of the selection of the new generation.
\begin{verbatim}
    for t in 1..NettoPopSize loop
      field := 101;
      while (field > 100) loop
        field := (random_ND_integer(65535) mod Position) + 1;
      end loop;
      New_Population(t) := Population(Wheel(field));
    end loop;
\end{verbatim}
Let the new generation take the place of the old one.
\begin{verbatim}
    for t in 1..NettoPopSize loop
      Population(t) := New_Population(t);
    end loop;
\end{verbatim}
This finishes the reproduction phase.
\begin{verbatim}
  end Roulette_Wheel;
\end{verbatim}
\subsubsection{The Crossover Procedure}
The crossover procedure is the expanded version of the SGA procedure. The interface of
this procedure is already explained in the section above.
\begin{verbatim}
  procedure Crossover (Population            : in out Population_Array;
                       Method                : in     Crossing;
                       Selection             : in     Haploid_Method;
                       Crossing              : in     Crossing_Points;
                       No_of_Crossing_Points : in     integer;
                       Generation_Gap        : in     integer) is
    New_Population          : Population_Array;
    Partner                 : array (Population'Range) of integer;
    x,y,z                   : integer := 0;
    filled                  : boolean;
    Selected_Partner        : integer := 0;
    Point_of_Crossover      : integer := 0;
    New_1st_Individuum      : Individuum;
    New_2nd_Individuum      : Individuum;
    Dummy                   : Individuum;
    Number_of_Partners      : integer := 0;
    Number_of_Partners_half : integer := 0;
\end{verbatim}
This internal function returns the dominant gene. It is only used, if the
crossover works in the diploid mode.
\begin{verbatim}
  function Dominant (x,y : in integer) return integer is
    Position_x : integer := 0;
    Position_y : integer := 0;
    begin
    for t in Crossing'Range loop
      if (Crossing(t) = x) then
        Position_x := t;
      end if;
      if (Crossing(t) = y) then
        Position_y := t;
      end if;
    end loop;
    if (Position_x > Position_y) then
      return Position_x;
    else
      return Position_y;
    end if;
    end Dominant;

  begin
    Number_of_Partners := MaxPopSize - Generation_Gap;
    Number_of_Partners_half := Number_of_Partners / 2;
-- Initialize the fields for the relationship
    for x in 1..Number_of_Partners loop
      Partner(x) := Population'Length + 1;
    end loop;
-- Select the partners
    for x in 1..Number_of_Partners_half loop
      Selected_Partner := (random_ND_integer(65535) mod Number_of_Partners_half)
                           + Number_of_Partners_half + 1;
      loop
        filled := false;
        for y in 1..x loop
          if (Partner(y) = Selected_Partner) then
            filled := true;
            Selected_Partner :=(random_ND_integer(65535) mod
                                                Number_of_Partners_half)
                                + Number_of_Partners_half;
            end if;
          end loop;
        exit when (filled = false);
      end loop;
      Partner(x) := Selected_Partner;
    end loop;
\end{verbatim}
If the crossover method is the hapoid crossover, then the procedure has to find
point of crossover and start the change of the genetic information. If fixed
points for the crossover are defined, then the procedure hat to use these points.
\begin{verbatim}
    if (Method = haploid) then
      for x in 1..Number_of_Partners_half loop
        New_1st_Individuum := Population(x);
        New_2nd_Individuum := Population(Partner(x));
        if (Selection = randomize) then
          Point_of_Crossover := (random_ND_integer(65535) mod
                                 Population(x)'Length);
        else
          Point_of_Crossover := Crossing(random_ND_integer(65535) mod
                                 (No_of_Crossing_Points + 1));
        end if;
        if (Point_of_Crossover > 0) then
          Dummy := New_1st_Individuum;
          for z in 1..Point_of_Crossover loop
            New_1st_Individuum(z) := New_2nd_Individuum(z);
            New_2nd_Individuum(z) := Dummy(z);
          end loop;
        end if;
        Population(x) := New_1st_Individuum;
        Population(Partner(x)) := New_2nd_Individuum;
      end loop;
\end{verbatim}
Else if the crossover method is diploid, the system has to use to priority table
\begin{verbatim}
    else
      for x in 1..Number_of_Partners_half loop
        New_1st_Individuum := Population(x);
        New_2nd_Individuum := Population(Partner(x));
        for z in New_1st_Individuum'Range loop
          Dummy(z) := Dominant(New_1st_Individuum(z),New_2nd_Individuum(z));
        end loop;
        Population(x)           := Dummy;
        Population(Partner(x))  := Dummy;
      end loop;
    end if;
\end{verbatim}
Final procedures of this phase
\begin{verbatim}
  end Crossover;
\end{verbatim}
\subsubsection{The Mutation Procedure}
With the exception of the generation gap, this procedure works identically to
the function of the SGA. It is important to notify, that most changes in the AGA
package belong to the crossover phase. This is an index for the fact, that this
phase still gives a lot work to do and that the best algorithm is still not found.
\begin{verbatim}
  procedure Mutation       (Population     : in out Population_Array;
                            Mutationquote  : in     float;
                            Generation_Gap : in     integer) is
    Number_of_Mutations   : integer := 0;
    Selected              : integer := 0;
    Point_of_Mutation     : integer := 0;
    Mutated_Gene          : integer := 0;
    Individuums_to_Mutate : integer := 0;
    Mutant                : Individuum;
    Quote                 : float;
    Correction            : float;

    begin
      Individuums_to_Mutate := MaxPopSize - Generation_Gap;
      Quote := Mutationquote;
      if (Mutationquote < 0.001) then
        put_line("Quote of Mutation too small ! Assumed new quote : 0.005 ");
        Quote := 0.005;
      elsif (Mutationquote > 0.999) then
        put_line("Quote of Mutation too big ! Assumed new quote : 0.005 ");
        Quote := 0.005;
      end if;
      Correction := 1000.0 / float(MaxPopSize);
      Number_of_Mutations := integer(Quote * float(MaxPopSize) * Correction);
      if (Number_of_Mutations > 0) then
        Number_of_Mutations := random_ND_integer(65535) mod Number_of_Mutations;
      end if;
      if (Number_of_Mutations > 0) then
        for x in 1..Number_of_Mutations loop
          Selected := (random_ND_integer(65535) mod Individuums_to_Mutate) + 1;
          Point_of_Mutation := (random_ND_integer(65535) mod
                                 Population(Selected)'Length) + 1;
          Mutant := Population(Selected);
          Mutated_Gene := Mutant(Point_of_Mutation);
          while (Mutated_Gene = Mutant(Point_of_Mutation)) loop
            Mutated_Gene := random_ND_integer(65535) mod 2;
          end loop;
          Mutant(Point_of_Mutation) := Mutated_Gene;
          Population(Selected) := Mutant;
        end loop;
      end if;
    end Mutation;
\end{verbatim}
\subsubsection{The SGA Simple Display Procedure}
I wanted to replace this function by a more sophisticating output procedure, but
there exists no common ADA graphics interface. To keep the procedure portable
I decided to keep the SGA output in use.
\begin{verbatim}
  procedure Simple_Display(Generation : integer;
                           Population : in Population_Array;
                           Fitness    : in Fitness_Array;
                           Org_Value  : in Fitness_Array;
                           Calc_Value : in Fitness_Array) is
  Single_Allele         : integer;
  Element               : Individuum;
  This_Gen_Accum_Org    : float;
  This_Gen_Accum_Calc   : float;
  Change_of_Accum_Calc  : float;
  
  begin
    new_page;
    put ("Genetic Algorithms Experimental Environment: Simple Display ");
    put_line ("Procedure");
    new_line;
    put ("Generation :");
    put (Generation);
    new_line;
    for T in Population'Range loop
      Element := Population(T);
      for X in Element'Range loop
        Single_Allele := Element(X);
        put(Single_Allele,1);
      end loop;
    put(" | "); put(integer(Fitness(T)),4);
    put(" | "); put(integer(Org_Value(T)),4);
    This_Gen_Accum_Org := This_Gen_Accum_Org + Org_Value(T);
    put(" | "); put(integer(Calc_Value(T)),4);
    This_Gen_Accum_Calc := This_Gen_Accum_Calc + Calc_Value(T);
    if (Best_Calc_Value < Calc_Value(T)) then
      Best_Calc_Value := Calc_Value(T);
      Best_Generation := Generation;
    end if;
    new_line;
    end loop;
    Change_of_Accum_Calc := This_Gen_Accum_Calc - Last_Gen_Accum_Calc;
    put("Best Fitness :  "); put(integer(Best_Calc_Value));
    put(" in Generation : "); put(Best_Generation); new_line;
    put("Accum. Fitness: "); put(integer(This_Gen_Accum_Calc));
    put(" Last Generation : "); put(integer(Last_Gen_Accum_Calc));
    put(" Change : "); put(integer(Change_of_Accum_Calc)); new_line;
    Last_Gen_Accum_Calc := This_Gen_Accum_Calc;
  end Simple_Display;
  
end Advanced_Genetic_Algorithms;
pragma LIST(OFF);
\end{verbatim}
This summery of procedures is just a skeleton of possible programming. I am sure, that the
efficancy of most of the procedures can be improved. So I want to encourage
the user of these packages to do so and use the possibilities of ADA for this
work.
