In the following package can be seen, that the package of two dimensional genetic
algorithms is very close to the package for advanced genetic algorithms. Therefor
I only describe the differences in the header and leave the package body. The
procedure for {\it simple display} is taken out.
\begin{verbatim}
pragma LIST(ON);

with text_io; use text_io;
with random; use random;
with fio; use fio;
with iio; use iio;

generic
\end{verbatim}
To be defined :
\begin{itemize}
\item {\tt MaxAllele\_x} = Numbers of alleles in an individual in x-direction
\item {\tt MaxAllele\_y} = Numbers of alleles in an individual in y-direction
\item {\tt MaxPopSize} = Number of Individuums in a Population
\end{itemize}
\begin{verbatim}
   MaxAllele_x	    	: integer;
   MaxAllele_y		: integer;
   MaxPopSize		: integer;
   MaxCrossPoints	: integer;

package 2D_Genetic_Algorithms is
\end{verbatim}
The first definitions are mostly identical to the AGA package
\begin{verbatim}
  type Sex		is (male,female);
  type Crossing		is (haploid, diploid);
  type Haploid_Method   is (fixed, randomize);
  type Individuum       is array (1..MaxAllele_x,1..MaxAllele_y) of 
				integer range 0..1;
  type Population_Array is array (1..MaxPopSize) of Individuum;
  type Fitness_Array    is array (1..MaxPopSize) of float;
  type Sex_Array	is array (1..MaxPopSize) of Sex;
  type Crossing_Points	is array (1..MaxCrossPoints,0..1) of integer;

  procedure Init_Population (Population : in out Population_Array);

  procedure Roulette_Wheel (Population     : in out Population_Array;
			    Fitness        : in     Fitness_Array;
			    Generation_Gap : in     integer);
  procedure Crossover      (Population            : in out Population_Array;
			    Method	          : in	    Crossing;
			    Selection             : in     Haploid_Method;
			    Crossing              : in     Crossing_Points;
		            No_of_Crossing_Points : in     integer;
			    Generation_Gap        : in     integer);
  procedure Mutation       (Population     : in out Population_Array;
			    Mutationquote  : in     float;
			    Generation_Gap : in     integer);

end 2D_Genetic_Algorithms;
\end{verbatim}
Next is the rest of the package. It is not documentated, but it should be easy to
modify it by using the documentation in the chapter before.
\begin{verbatim}
package body 2D_Genetic_Algorithms is

  Best_Org_Value	: float := 0.0;
  Best_Calc_Value	: float := 0.0;
  Best_Generation	: integer := 0;
  Last_Gen_Accum_Org	: float := 0.0;
  Last_Gen_Accum_Calc	: float := 0.0;

  procedure Init_Population (Population : in out Population_Array) is
    t, x		: integer;
    Single_Individuum	: Individuum;
  begin
    for t in Population'Range loop
      for x in Population(t)'Range loop
        Single_Individuum(x) := random_ND_integer(65535) mod 2;
	if (Single_Individuum(x) > 1) then
	  Single_Individuum(x) := 1;
        end if;
      end loop;
      Population(t) := Single_Individuum;
    end loop;
  end Init_Population;
  
  procedure Roulette_Wheel (Population     : in out Population_Array;
			    Fitness        : in     Fitness_Array;
			    Generation_Gap : in     integer) is
    New_Population : Population_Array;
    Gap		   : Population_Array;
    Gap_Array      : array (1..MaxPopSize) of integer;
    Wheel_Length   : constant := 100;
    Wheel          : array (1..Wheel_Length) of integer;
    Position       : integer := 1;
    t              : integer;
    x              : integer;
    field          : integer;
    NettoPopSize   : integer;
    Dummy	   : integer;

  begin
    NettoPopSize := MaxPopSize - Generation_Gap;
-- Initialization of the Roulette Wheel. Every Individuum gets fields,
-- iff it's Fitness is better then 1 % of the accumulated fitness in the
-- system. This will be less or equal 100 fields on the Roulette Wheel.
    for t in Population'Range loop
      if (Fitness(t) >= 1.0) then
	for x in Position..(Position+integer(Fitness(t))) loop
	  if (x <= 100) then
	    Wheel(x):=t;
          end if;
	end loop;
	Position := Position + integer(Fitness(t));
      end if;
    end loop;
-- Move best Individuums into the Gap
-- Sort fitness
    for t in Population'Range loop
      Gap_Array(t) := t;
    end loop;
    for t in Population'Range loop
      for x in t..MaxPopSize loop
	if (Fitness(Gap_Array(t)) > Fitness(Gap_Array(x))) then
	  Dummy        := Gap_Array(t);
	  Gap_Array(t) := Gap_Array(x);
	  Gap_Array(x) := Dummy;
	end if;
      end loop;
    end loop;
    for t in 1..Generation_Gap loop
      Population(NettoPopSize + t) := Population(Gap_Array(t));
    end loop;
-- Start of the selection of new generation.
    for t in 1..NettoPopSize loop
      field := 101;
      while (field > 100) loop
        field := (random_ND_integer(65535) mod Position) + 1;
      end loop;
      New_Population(t) := Population(Wheel(field));
    end loop;
-- Let the new generation take the place of the old one.
    for t in 1..NettoPopSize loop
      Population(t) := New_Population(t);
    end loop;
-- Finished and end of the reproduction phase.
  end Roulette_Wheel;

  procedure Crossover (Population            : in out Population_Array;
		       Method	             : in     Crossing;
		       Selection             : in     Haploid_Method;
		       Crossing              : in     Crossing_Points;
		       No_of_Crossing_Points : in     integer;
		       Generation_Gap        : in     integer) is
    New_Population          : Population_Array;
    Partner                 : array (Population'Range) of integer;
    x,y,z	            : integer := 0;
    z1.z2                   : integer := 0;
    filled	            : boolean;
    Selected_Partner        : integer := 0;
    Point_of_Crossover      : integer := 0;
    New_1st_Individuum      : Individuum;
    New_2nd_Individuum      : Individuum;
    Dummy	            : Individuum;
    Number_of_Partners      : integer := 0;
    Number_of_Partners_half : integer := 0;

  function Dominant (x,y : in integer) return integer is
    Position_x : integer := 0;
    Position_y : integer := 0;
    begin
    for t in Crossing'Range loop
      if (Crossing(t) = x) then
	Position_x := t;
      end if;
      if (Crossing(t) = y) then
	Position_y := t;
      end if;
    end loop;
    if (Position_x > Position_y) then
      return Position_x;
    else
      return Position_y;
    end if;
    end Dominant;

  begin
    Number_of_Partners := MaxPopSize - Generation_Gap;
    Number_of_Partners_half := Number_of_Partners / 2;
-- Initialize the fields for the relationship
    for x in 1..Number_of_Partners loop
      Partner(x) := Population'Length + 1;
    end loop;
-- Select the partners
    for x in 1..Number_of_Partners_half loop
      Selected_Partner := (random_ND_integer(65535) mod Number_of_Partners_half)
			   + Number_of_Partners_half + 1;
      loop
	filled := false;
	for y in 1..x loop
	  if (Partner(y) = Selected_Partner) then
	    filled := true;
            Selected_Partner :=(random_ND_integer(65535) mod
	    					Number_of_Partners_half)
				+ Number_of_Partners_half;
	    end if;
	  end loop;
	exit when (filled = false);
      end loop;
      Partner(x) := Selected_Partner;
    end loop;
-- If Crossover Method is hapoid Crossover, then find Point of Crossover 
-- and start the change of the genetic information. If fixed points for
-- Crossover are defined, then use these points.
    if (Method = haploid) then
      for x in 1..Number_of_Partners_half loop
        New_1st_Individuum := Population(x);
        New_2nd_Individuum := Population(Partner(x));
	if (Selection = randomize) then
          Point_of_Crossover_x := (random_ND_integer(65535) mod 
			 	   MaxAllele_x);
          Point_of_Crossover_y := (random_ND_integer(65535) mod
                                   MaxAllele_y);
        else
	  Point_of_Crossover_x := Crossing(random_ND_integer(65535) mod 
				 (No_of_Crossing_Points + 1),0);
	  Point_of_Crossover_y := Crossing(random_ND_integer(65535) mod 
				 (No_of_Crossing_Points + 1),1);
        end if;
        if (Point_of_Crossover > 0) then
          Dummy := New_1st_Individuum;
          for z1 in 1..Point_of_Crossover_x loop
            for z2 in 1..Point_of_Crossover_y loop
	    New_1st_Individuum(z1,z2) := New_2nd_Individuum(z1,z2);
	    New_2nd_Individuum(z1,z2) := Dummy(z1,z2);
          end loop;
        end if;
        Population(x) := New_1st_Individuum;
        Population(Partner(x)) := New_2nd_Individuum;
      end loop;
-- else Crossover Method is diploid, and the System has to use to priority-
-- table
    else
      for x in 1..Number_of_Partners_half loop
        New_1st_Individuum := Population(x);
        New_2nd_Individuum := Population(Partner(x));
	for z1 in 1..MaxAllele_x loop
          for z2 in 1..MaxAllele_y loop
	  Dummy(z1,z2) := Dominant(New_1st_Individuum(z1,z2),
                                   New_2nd_Individuum(z1,z2));
	end loop;
	Population(x)		:= Dummy;
	Population(Partner(x))	:= Dummy;
      end loop;
    end if;
-- Final procedures of this phase
  end Crossover;

  procedure Mutation       (Population     : in out Population_Array;
			    Mutationquote  : in     float;
		            Generation_Gap : in     integer) is
    Number_of_Mutations   : integer := 0;
    Selected		  : integer := 0;
    Point_of_Mutation_x   : integer := 0;
    Point_of_Mutation_y   : integer := 0;
    Mutated_Gene	  : integer := 0;
    Individuums_to_Mutate : integer := 0;
    Mutant		  : Individuum;
    Quote		  : float;
    Correction		  : float;

    begin
      Individuums_to_Mutate := MaxPopSize - Generation_Gap;
      Quote := Mutationquote;
      if (Mutationquote < 0.001) then
	put_line("Quote of Mutation too small ! Assumed new quote : 0.005 ");
	Quote := 0.005;
      elsif (Mutationquote > 0.999) then
	put_line("Quote of Mutation too big ! Assumed new quote : 0.005 ");
	Quote := 0.005;
      end if;
      Correction := 1000.0 / float(MaxPopSize);
      Number_of_Mutations := integer(Quote * float(MaxPopSize) * Correction);
      if (Number_of_Mutations > 0) then
        Number_of_Mutations := random_ND_integer(65535) mod Number_of_Mutations;
      end if;
      if (Number_of_Mutations > 0) then
	for x in 1..Number_of_Mutations loop
	  Selected := (random_ND_integer(65535) mod Individuums_to_Mutate) + 1;
	  Point_of_Mutation_x := (random_ND_integer(65535) mod
	                         MaxAllele_x) + 1;
	  Point_of_Mutation_y := (random_ND_integer(65535) mod
	                         MaxAllele_y) + 1;
	  Mutant := Population(Selected);
	  Mutated_Gene := Mutant(Point_of_Mutation_x,Point_of_Mutation_y);
	  while (Mutated_Gene = Mutant(Point_of_Mutation_x,Point_of_Mutation_y)) loop
            Mutated_Gene := random_ND_integer(65535) mod 2; 
          end loop;
	  Mutant(Point_of_Mutation_x,Point_of_Mutation_y) := Mutated_Gene;
          Population(Selected) := Mutant;
	end loop;
      end if;
    end Mutation;

end 2D_Genetic_Algorithms;
pragma LIST(OFF);
\end{verbatim}
